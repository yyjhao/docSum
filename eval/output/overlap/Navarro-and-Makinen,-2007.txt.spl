to discover each such character ta -LSB- j -RSB- , for j = i , ^ -LSB- i -RSB- , ^ -LSB- ^ -LSB- i -RSB- -RSB- , ... , we can use the same table c : because the first characters ta -LSB- j -RSB- of the suffixes ta -LSB- j -RSB- , n , are in alphabetic order in a , ta -LSB- j -RSB- must be the character c such that c -LSB- c -RSB- &lt; j &lt; c -LSB- c + 1 -RSB- .
to ensure the extra space stays o -LRB- n log ^ -RRB- we must ensure 2h ' = o -LRB- log n \/ log log n -RRB- , for example , h ^ &lt; -LRB- ^ c -LRB- 9 , ~ t -RRB- ^ ^ -RRB- log log ^ n c -LRB- 9 , ~ t -RRB- 2 log log log n .
the search time added over 1 + 1 \/ ^ levels in 0 &lt; ^ &lt; h ^ is o -LRB- log , + ^ n \/ -LRB- log log n -RRB- 2 -RRB- , while the time to move from level h ^ to h is o -LRB- 2h ^ h ^ c -LRB- 9 , ~ t -RRB- 2h ' log ^ -RRB- = o -LRB- log n log log n -RRB- .
the most relevant ones obtain , roughly , o -LRB- m \/ log ^ n + log 1 % n -RRB- counting time with e
ferragina and manzini -LSB- 2005 -RSB- use for range the structure of alstrup et al. -LSB- 2000 -RSB- -LRB- see section 6.4 -RRB- that can store n ^ points in -LSB- 1 , n ^ -RSB- x -LSB- 1 , n ^ -RSB- using o -LRB- n ^ log1 + ^ n ^ -RRB- bits for any ^ &gt; 0 , so that they answer a query with res results in time o -LRB- log log n ^ + res -RRB- .
